# Java线程与锁

## 进程与线程

- 进程：操作系统分配资源的最小单元，包括多个线程，这些线程共享本进程的内存和资源
- 线程：操作系统调度的最小单元

### 线程的状态

![](C:\Users\15893\Pictures\Saved Pictures\20181210192426949.png)

实现线程的几种方式

- 继承Thread类
- 实现Runnable接口
- 实现Callable接口

ThreadPool线程池的用法

ThreadPoolExecutor创建线程池，5参构造方法参数：

- int corePoolSize：线程池中核心线程数，一般为cpu数量


- int maximumPoolSize： 线程池中线程总数，一般为2*cpu数量(I/O密集型时maxSize设置大一点，提高cpu利用率)


- long keepAliveTime：线程池中非核心线程闲置超时时长


- TimeUnit unit：keepAliveTime的单位


- BlockingQueue workQueue：线程池中的任务队列，维护着等待执行的Runnable对象
  - SynchronousQueue：接收到任务时，会直接提交给线程处理，而不保留它

  - LinkedBlockingQueue：接收到任务时，如果当前线程数小于核心线程数，则新建核心线程处理任务；如果当前线程数等于核心线程数，则进入队列等待

  - ArrayBlockingQueue：接收到任务时，如果没有达到corePoolSize的值，则新建核心线程执行任务；如果达到了，则入队等候；如果队列已满，则新建非核心线程执行任务；如果总线程数到了maximumPool，且队列也满了，则发生错误

  - DelayQueue：接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。注意：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口

- RejectedExecutionHandler handler：BlockingQueue 打满时的几种拒绝策略
  - Abort策略：默认策略，新任务提交时直接抛出未检查的异常。
  - RejectedExecutionException，该异常可由调用者捕获。
  - CallerRuns策略：为调节机制，既不抛弃任务也不抛出异常，而是将某些任务回退到调用者。不会在线程池的线程中执行新的任务，而是在调用exector的线程中运行新的任务。
  - Discard策略：新提交的任务被抛弃。
  - DiscardOldest策略：队列的是“队头”的任务，然后尝试提交新的任务。

向线程池提交一个任务：threadPoolExecutor.execute(runnable);

当新提交一个任务时：

- 如果当前线程数<corePoolSize，新增一个核心线程处理新的任务。
- 如果当前线程数=corePoolSize，新任务会被放入阻塞队列等待。
- 如果阻塞队列满了，且当前线程数<maximumPoolSize，新增线程来处理任务。
- 如果阻塞队列满了，且当前线程数=maximumPoolSize，那么线程池已达极限，此时会根据饱和策略RejectedExecutionHandler拒绝新的任务。

还可以使用Executors 类，创建ExecutorService线程池对象：

```java
//创建线程池
ExecutorService executor = Executors.newFixedThreadPool(number);
//加入线程任务
executor.executor(runnable1);
executor.executor(runnable2);
//关闭线程池:
//shutdown()--线程池不再接收新任务，目前未执行完的任务完成后关闭
//shutdownNow()--立刻关闭线程池，即使有未完成任务，返回未完成任务列表
executor.shutdown();
```

使用线程池的优势：

- 降低资源消耗：重复利用已创建的线程，降低创建和销毁造成的消耗。
- 提高响应速度：任务可以不需要等到线程创建就能立即执行(参考上条)。
- 提高管理性：可以进行统一的分配、调优和监控。

concurrent包：

- Executor接口：具体Runnable任务的执行者。

- Executors类：创建线程池工具类（阿里手册禁止用此工具类）。
- ExecutorService接口：线程池管理者，可提交Runnable、Callable让其调度。
  ThreadPoolExecutor类：线程池工具类。（ExecutorService的一种具体实现）。
- CompletionService接口：ExecutorService的扩展，可以获得线程执行结果。
- ReentrantLock类：可重入互斥锁（实现Lock接口）。
- BlockingQueue接口：阻塞队列。
- Future接口：一个线程执行结束后取返回的结果，还提供了cancel()终止线程。
- CountDownLatch类：当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。

## 锁

### 死锁产生的必要条件：

- 互斥条件
- 不剥夺条件
- 请求和保持条件
- 环路等待条件

### 避免死锁：

- 加锁顺序
- 加锁时限
- 死锁检验

### 锁的类型

|            锁            |                             解释                             |
| :----------------------: | :----------------------------------------------------------: |
|     公平锁/非公平锁      |    公平锁指多个线程按照申请锁的顺序获取锁，非公平则为随机    |
|         可重入锁         |    同一线程在外层方法已获得锁时，进入内层方法会自动获取锁    |
|      独享锁/共享锁       | 一次可以被单个/多个线程所持有的，例如ReadWrieLock的的写锁/读锁 |
|      互斥锁/读写锁       |     一种互斥锁：ReentrantLock；一种读写锁：ReadWriteLock     |
|      乐观锁/悲观锁       | 悲观锁人为对同一个数据的并发操作一定会发生修改，乐观锁则不然 |
|          分段锁          |          一种锁的设计，具体用用有ConcurrentHashMap           |
|          自旋锁          | 尝试获取锁的线程不会立即阻塞，而是会采用循环的方式去尝试获取 |
| 偏向锁/轻量级锁/重量级锁 |              指锁的状态，并且是针对synchronized              |

**偏向锁**是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。

**轻量级锁**是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁**是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但当自旋一定次数还没获取到锁的时候，就会进入阻塞，该锁膨胀为重量级锁。

### synchronized和vilatile

synchronized是java的关键字，是一种同步锁

- 锁的级别有对象级别和类级别
- 修饰方法和代码块时为对象级别，修饰类时是类级别

vilatile是告诉JVM当前变量在CPU缓存中的值是不确定的，需要从主存中读取（禁止指令的重排序）；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。

| 比较点   | volatile                 | synchronized               |
| -------- | ------------------------ | -------------------------- |
| 阻塞     | 不会发生线程阻塞         | 会发生线程阻塞             |
| 修饰     | 变量                     | 方法、代码块、类           |
| 原子性   | 不能保证                 | 可以保证                   |
| 安全性   | 非线程安全               | 线程安全                   |
| 解决问题 | 变量在多线程之间的可见性 | 多线程之间访问资源的同步性 |

### synchronized和Lock

比较点	sychronized	Lock
解释	Java关键字	Java接口
显隐	隐式锁	需显示指定起始位置和终止位置
释放锁	获取锁的线程会在执行完同步代码后自动释放锁（或者JVM会在线程执行发生异常时释放锁）	在finally中必须释放锁，不然容易造成线程死锁
等待	一个线程获得锁后阻塞，其他线程会一直等待	线程不会一直等待，超时会释放
锁类型	可重入但不可中断、非公平	可重入、可中断、可公平也可不公平

| 比较点 | sychronized                                                  | Lock                                        |
| ------ | ------------------------------------------------------------ | ------------------------------------------- |
| 解释   | Java关键字                                                   | Java接口                                    |
| 显隐   | 隐式锁                                                       | 需显示指定起始位置和终止位置                |
| 释放锁 | 获取锁的线程会在执行完同步代码后自动释放锁（或者JVM会在线程执行发生异常时释放锁） | 在finally中必须释放锁，不然容易造成线程死锁 |
| 等待   | 一个线程获得锁后阻塞，其他线程会一直等待                     | 线程不会一直等待，超时会释放                |
| 锁类型 | 可重入但不可中断、非公平                                     | 可重入、可中断、可公平也可不公平            |

### sleep()和wait()，yield()和notify()

- sleep()是Thread类的一个静态函数，它会使调用线程睡眠(阻塞)一段时间，让其他线程有机会继续执行，但它不释放锁。
- wait()是Object类的方法，它会使当前线程阻塞，直到调用notify()，则被唤醒，它会释放锁。
- yield()是Thread类的方法，它会使运行中的线程重新变为就绪状态，让同优先级线程重新竞争。
- notify()是Object类的方法，它会唤醒单个线程。

### 分布式锁

  一种跨服务器(JVM)控制共享资源访问的互斥机制。在分布式系统环境下，一个方法在同一时间只能被一台机器的一个线程执行。

- 基于数据库实现分布式锁：在数据库中创建一张表，表中包含方法名字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。
- 基于缓存（Redis等）实现分布式锁：获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为当前时间加上锁定时间，释放锁的时候执行delete进行释放。

- 基于Zookeeper实现分布式锁：①创建一个目录dislock；②线程A想获取锁就在dislock目录下创建临时顺序节点；③获取dislock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；④线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；⑤线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。