# java JVM

## jvm的24个面试题

### 1. 什么是jvm，怎样理解java是“平台无关的编程语言”？

​		jvm是一个可以执行java字节码的虚拟机进程。java源文件被编译成能被jvm执行的字节码文件。java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每个平台单独重写或者重新编译。正是jvm使之成为可能，因为他知道底层硬件平台的指令长度和其他特性。

### 2. java的内存结构

![](C:\Users\15893\Pictures\Saved Pictures\16bd08c33a3d751b.webp)

**方法区和堆是所有线程共享的区域**；**而java栈、本地方发栈和程序计数器是运行时线程私有的区域。**

- java堆（Heap），是java虚拟机所管理的内存中最大的一块。java堆在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
- 方法区（Method Area），与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 程序计数器（Program Counter Register），是线程私有的一块较小的内存空间，他的作用可以看做使当前线程所执行的字节码的行号指示器。
- JVM栈（JVM Stack），与程序计数器一样，java虚拟机栈也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

- 本地方法栈（Native Method Stack），与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。

### 3. 解释内存中的栈、堆和方法区的用法

​		通常定义一个真笨数据类型的变量。一个对象的引用，还有就是函数调用的现场保存都使用jvm的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老年代，再具体一点可以分为Eden、Survivor（又可以分为From Survivor和To Survivor）、Thenured（P53）；方法区和堆都是各个线程共享的内存区域，用于存储已被jvm加载的类信息、常量、静态变量。jit编译期变异后的代码等数据；程序中的字面量如直接书写的100、“hello”和常量都是放在常量池中，常量池是方法去的一部分。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都是可以通过jvm的启动参数再进行调整的，栈空间用光了会报StakOverflowError，而堆和常量池空间不足则会引发OutOfMenoryError。

```java
String str = new String("hello");
```

这个语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量放在方法区。

补充1：较新版本的java（从java6的某个更新开始），由于jit编译器的发展和“逃逸分析（P309）”技术的逐渐成熟，栈上分配、标量替换等优化技术使对象一定分配在堆上这件事情已经变得不那么绝对。

补充2：运行时常量池相当于class文件常量池就有动态性，java语言并不要求常量池一定只由编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern方法就是这样的。

```java
String s0=”kvill”; 
String s1=”kvill”; 
String s2=”kv” + “ill”; 
System.out.println( s0==s1 ); 
System.out.println( s0==s2 );
//结果：
true
true
```

- java会确保一个字符串常量只有一个拷贝。
- 上面的代码s2时两个字符串场连接而成的，他自己肯定也是字符串常量，所以ss0==s1==s2都是常量池“kvill”的引用

```java
String s0=”kvill”; 
2 String s1=new String(”kvill”); 
3 String s2=”kv” + new String(“ill”); 
4 System.out.println( s0==s1 ); 
5 System.out.println( s0==s2 ); 
6 System.out.println( s1==s2 );
//结果：
false
false
false
```

- 用new创建的字符串不是常量，不能在编译期就确定，所以new String（）创建出的字符串不能放入常量池，有他自己的地址
- s0还是常量池中的引用，而s1无法在编译期确定，所以是新的对象的引用，s2后半部分也无法在编译期确定，所以也是一个新对象

**String.intern():** 存在于.class文件中的常量池，在运行期被JVM装载，并且**可以扩充**。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用 

```java
String s0= “kvill”; 
String s1=new String(”kvill”); 
String s2=new String(“kvill”); 
System.out.println( s0==s1 ); 
s1.intern(); 
s2=s2.intern(); //把常量池中“kvill”的引用赋给s2 
System.out.println( s0==s1); 
System.out.println( s0==s1.intern() ); 
System.out.println( s0==s2 );
//结果
false
false		//虽然执行了s1.intern()但是并未对s1重新赋值
true		//说明s1.intern()返回值为常量池中的引用
true
```

### 4. 对象分配规则

- 对象优先分配在Eden区，如果Eden区没有足够的空间，虚拟机执行一次Minor GC。
- 大对象直接进入老年代（大对象指需要大量连续空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阈值对象进入老年区。
- 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象可以直接进入老年代。
- 空间分配担保。每次进行Minor GC时，jvm会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于，检查HandlePromotionFailure设置是否允许担保失败，如果true，则只进行Mintor GC，如果false，则还要进行FullGC

### 5. 什么是类的加载

​		类的加载指：将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个Java.lang.Class对象，用来封装类在方法区的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法去内的数据结构，并且向java程序员提供了访问方法去内的数据结构的接口。

​		**类加载时机：**类从被加载到虚拟机内存开始，到卸载出内存为止，他的整个生命周期包括了：**加载、验证、准备、解析、初始化、使用**和**卸载**七个阶段，其中**验证、准备和解析**统称为**连接**。

- 加载：
  - 通过全限定名获取二进制字节流
  - 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口

- 验证：
  - 文件格式验证
  - 元数据验证（主要验证其继承，实现接口，类中的字段或方法是否与父类冲突）
  - 字节码验证
  - 符号引用验证

- 准备：
  - 为类变量分配内存并设置类变量初始值（**与方法内变量区分开**）

- 解析：
  - 虚拟机将常量池内的符号引用替换为直接引用的过程

- 初始化：
  - 真正开始执行java程序代码，初始化变量和其他资源

### 6. 类加载器

![](C:\Users\15893\Pictures\Saved Pictures\16bd08c33a76aaf1.webp)

- 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK/jre/lib下，或被-Xbootclasspath参数指定的路径中，并且能被虚拟机识别的类库
- 扩展类加载器：Extension ClassLoader， 该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 
- 应用程序类加载器： Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器 

- 双亲委派模型：当一个类加载器拿到类加载任务时，会首先尝试让其父类完成类加载任务，如果父类无法完成类加载任务则自己尝试完成类加载任务。
- 但JNDI服务（目的就是对资源进行集中管理和查找）由启动类加载器完成类加载，需要调用在classpath下的接口提供者SPI的代码，java团队设计了线程上下文类加载器：父类请求子类完成类加载任务。双亲委派模型被第二次破坏（共三次）

- 在OSGi环境下java的类加载器不再是双亲委派模型，而是网状结构，当收到类加载任务时：
  - 将以java.*开头的类委派给父类加载器加载
  - or，将委派名单内的类，委派给父类加载器加载
  - or，将Import列表中的类，委派给Export这个类的Bundle（程序模块）的类加载器
  - or，查找当前Bundle的classpath，使用自己的类加载器加载
  - or，查找类是否在自己的Fragment Bundle中，如果在，委派给Fragment Bundle的类加载器加载
  - or，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载
  - or，类查找失败

### 7. 描述下JVM加载class文件的原理机制

​		JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。

​		由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：

- 1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；
- 2)如果类中存在初始化语句，就依次执行这些初始化语句。	

类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。

​		从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：

- Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
- Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
- System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

### 8. java创建对象的过程

1. jvm遇到一条新建对象的指令时，首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用，然后去加载这个类。
2. 为对象分配内存。一种办法为“指针碰撞”，一种办法为“空闲列表”，最终常用的办法为“本地线程缓冲分配（TLAB）”

3. 将对象头外的对象内存空间初始化为0
4. 对对象头进行必要设置

### 9.类的生命周期

![](C:\Users\15893\Pictures\Saved Pictures\16bd08cb08ee6ea4.webp)



- 加载，查找并加载类二进制数据，在java对中创建一个java.long.Class对象
- 连接，包含三部分内容：验证、准备、解析
  - 验证：文件格式、元数据、字节码、符号引用验证
  - 准备：为类的静态字段分配内存，并将其初始化为默认值
  - 解析：把类中的符号引用转换为直接引用

- 初始化：为类的静态变量赋予正确的初始值
- 使用，new出对象使用
- 卸载，执行垃圾回收

### 10. java对象结构

java对象有三部分组成：对象头、实例数据、对其填充。

**对象头**由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64bit）。第二部分为指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。

**实例数据**用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）

**对其填充**：jvm要求对象起始地址必须是8字节的整数倍（8字节对齐）

### 11. java对象的定位方式

句柄池：java栈中引用（reference）中存储的是java堆中句柄池的地址，该地址有两个指针，对象实例指针指向java堆的实例池中该对象实例数据，对象数据类型指针指向方法区该对象类型数据。优点：reference在对象移动（GC）时不需要改变。

直接指针：java栈中引用（reference）中存储的是Java堆中对象实例数据地址，而对象实例数据中有指针指向方法区的该对象类型信息。优点：少一次指针中转，访问速度更快。

<img src="C:\Users\15893\Pictures\Saved Pictures\QQ图片20200316093103.jpg" style="zoom:80%;" />

### 12.如何判断对象可以被回收

判断对象存活一般有两种方式：

- 引用计数：每个对象有一个引用计数属性，新增一个引用时计数+1，引用释放时计数-1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
- 可达性分析：从GC Roots开始向下搜索，搜索搜走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用，不可达。

### 13.jvm永久代中会发生垃圾回收吗

垃圾回收不会发生在永久代，如果永久代满了或者超过了临界值，会触发完全垃圾回收（Full GC），此时永久代也是被回收。这就是正确的永久代大小对避免Full GC时非常重要的原因。java8：从永久代到元数据区（注：java8中已经移除了永久代，新加了一个叫做元数据区的native内存区）。

### 14.引用的分类

- 强引用：GC时不会被回收

- 软引用：有用但不是必须的对象，在发生内存溢出异常之前被回收
- 弱引用：有用但不是必须的对象，在下一次GC时被回收
- 虚（幽灵/幻影）引用：无法通过虚引用获得对象，用plantomReference实现虚引用，虚引用用来在GC时返回一个通知。

### 15.解释GC，为什么要用GC

GC即垃圾回收， Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。  Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。 

 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。 

 垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 （不可预知性）

**垃圾回收机制**有很多种，包括：**分代复制垃圾回收、标记垃圾回收、增量垃圾回收等**方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”：

- 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
- 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。（默认与Eden空间大小为8:1）
- 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。

与垃圾回收相关的JVM参数：

```java
-Xms/-Xmx:						//堆的初始大小/堆的最大大小
-Xmn:							//堆中年轻代的大小
-XX:-DisableExplicitGC			//让System.gc()不产生任何作用
-XX:+PrintGCDetails				//打印GC的细节
-XX:+PrintGCDateStamps			//打印GC操作的时间戳
-XX:NewSize/-XX:MaxNewSize		//设置新生代大小/新生代最大大小
-XX:NewRatio					//设置老生代和新生代的比例
-XX:PrintTenuringDistribution	//设置每次新生代GC后输出Survivor中对象年龄的分布
-XX:InitialTenuringThreshold/-XX:MaxTenuringThreshold
    							//设置老年代阈值的初始值和最大值
-XX:TargetSurvivorRatio			//设置Survivor的目标使用率
```

### 16.判断应对向应该被回收

1. 该对象没有与GC Roots连接
2. 该对象没有重写finalize()方法或者已执行过一次finalize()则直接回收（第一次标记）。否则将对象加入到F-Queue队列中，在这里finalize()方法被执行，之后进行第二次标记，如果对象还没有链接到引用，则GC，否则移除队列。

### 17.回收方法区

方法区回收价值很低，主要回收废弃的常量和无用的类。

如何判断无用的类：

1. 该类的所有实例都被回收（java堆中没有该类的对象）
2. 加载该类的ClassLoader已经被回收
3. 该类对应的java.long.Class对象没有在任何地方被引用，无法在任何地方利用反射访问该类

### 18.垃圾收集算法

GC最基础的算法有：标记-清除、复制、标记-压缩，常用的垃圾回收期采用分代收集算法。

- 标记-清除算法：分标记和清除两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
- 复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当着一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉。
- 标记-压缩算法：标记过程与标记-清除算法一致，但后续让搜用存库ode对象都向一端移动，然后直接清理掉端边界以外的内存。
- 分代收集算法：吧java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

### 19.垃圾回收器

- Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。
- ParNew收集器，时Serial收集器的多线程版本。
- Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
- Parallel Old收集器，Parallel Old是Parallel Scavenger收集器的老年代版本，使用多线程和“标记-整理”算法。
- CMS收集器，是一种以获取最短回收停顿时间为目标的收集器。
- G1收集器，是一款面向服务器的垃圾收集器，主要针对配备多个处理器及大容量内存的及其，以极高概率满足GC停顿时间要求的同事，还具备高吞吐量性能特征

### 20.GC日志分析

```java
2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K->10738K(274944K)] 371093K->147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]  

2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K->0K(274944K)] [ParOldGen: 136447K->140379K(302592K)] 147186K->140379K(577536K) [PSPermGen: 85411K->85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]
```

通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数

### 21.调优命令

Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo

- jps，jvm Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程。
- jstat，jvm statistics monitoring，用于监视虚拟机运行时状态信息的命令，可以显示出虚拟机进程中的类装载、内存、垃圾收集、jit编译等运行数据。
- jmap，jvm Memory Map，用于生成heap dump文件。
- jhat，jvm heap analysis tool，与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的http/html服务器，生成dump的分析结果后，可以在浏览器中查看。
- jstack，用于生成java虚拟机当前时刻的线程快照。
- jinfo，jvm Configuratuin info，实时查看和调整虚拟机运行参数。

### 22.调优工具

常用调优工具分为两类，jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT（memory analyzer tool）、GChisto。

- jconsole，java monitiring management console，是从java5开始，在jdk中自带的java监控和管理控制台，用于对jvm中内存，线程和类等的监控。
- jvisualvm，jdk自带的全能工具，可以分析内存快照。线程快照；监控内存变化、GC变化等。
- MAT，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。
- GChisto，一款专一分析gc日志的工具。

### 23.Minor GC与Full GC分别在什么时候发生

新生代内存不够时发生MGC也叫YGC，JVM内存不够时发生FGC。

### 24.jvm性能调优

- 设定堆内存大小

```java
-Xmx:			//堆内存最大限制
```

- 设定新生代大小，新生代不宜太小，否则会有大量对象涌入老年代

```java
-XX:NewSize:		//新生代大小
-XX:NewRatio:		//新生代和老年代占比
-XX:SurvivorRatio:	//Eden空间和Survivor空间占比（默认8:1）	
```

- 设定垃圾回收器


```java
-XX:+UseParNewGC		//为年轻代设定
-XX:+UseConcMarkSweepGC	//为老年代设定
```





