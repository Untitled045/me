# 计算机网络

## OSI与TCP/IP各层的结构与功能

![](C:\Users\15893\Pictures\Saved Pictures\164e5307471e8eba.webp)

我们一般采用折中的方法，使用5层结构。

### 1.物理层

​		物理层传送的数据单位时比特，物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。

### 2.数据链路层

​		数据链路层简称数链层，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数链层将网络层叫下来的数据组装成**帧**，在两个相邻接点之间传送帧。每一帧包括数据和必要的控制信息（同步信息、地址信息、差错控制等）。

​		在接受数据时，控制信息时的接收端能够知道一个帧从哪个比特开始，带哪个比特为止。这样，数据链路层在收到一个帧后，就可以从中提出数据部分，上交给网络层。控制信息还能使接收端检测收到帧中是否出错，如果出错，数链层就直接丢弃，避免继续传送白白浪费网络资源。

### 3.网络层

​		网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把传输层产生的报文段或用户数据包封装成**分组和包**进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报。

​		网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分组能够通过网络层中的路由器找到目的主机。

#### IP地址划分

![](C:\Users\15893\Pictures\Saved Pictures\1724098-023e4127a105423d.webp)

- A类：网络前导位为0，网络位8位，1.0.0.0---127.255.255.255，其中网路位为127的地址表示回送地址，指本机。网络位为0的保留。
- B类：网络前导位为10，网络位16位，128.0.0.0---191.255.255.255
- C类：网络前导位为110，网络位24位，192.0.0.0---223.255.255.255
- D类：网络前导位为1110，组播地址，224.0.0.0---239.255.255.255
- E类：保留地址，前导位为11110，240.0.0.0---255.255.255.255

其中A、B、C类地址可供普通用户使用。

**私有IP地址：**

IP地址分为：公有地址和私有地址（也称外部IP地址与内部IP地址，或全局IP地址与专用IP地址），在互联网中，公有IP可以被外网访问，私有IP仅用于内部网络使用，不能被外网访问到。私有IP地址如下：

- A类：10.0.0.0---10.255.255.255
- B类：172.16.0.0---172.31.255.255
- C类：192.168.0.0---192.168.255.255

IP地址的相关规定

- IP地址由“网络位”+“主机位”组成
- 网络地址：主机位全0
- 主机地址：网络位全0
- 直接广播地址：主机位全1

举例：ip地址为：201.161.20.18，网络地址：201.161.20.0，主机地址：0.0.0.18，直接广播地址：201.161.20.255。

**IP地址可用性**

- 主机位全为0或1不可用。
- 在一个网段内，最小的可用地址是网络地址+1，最大的可用地址是广播地址-1。
- 受限广播地址（有限广播地址：255.255.255.255）不能当主机IP。受限广播地址与直接广播地址区别：交换机转发广播，路由器不转发广播

子网掩码：用来区别网络位和主机位。用1表示网络位，用0表示主机位

### 4.传输层

​		传输层的主要任务时负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。

**传输层的两大协议**

- **传输控制协议TCP （Transmisson Control Protocol）--提供面向连接的，可靠的数据传输服务。** 
- **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

#### UDP 的主要特点

- UDP 是无连接的；
- UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
- UDP 是面向报文的；
- UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；
- UDP 支持一对一、一对多、多对一和多对多的交互通信；
- UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

#### TCP 的主要特点

1. TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
2. 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；
3. TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
5. 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

### 5.应用层

**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 **HTTP 协议**，支持电子邮件的 **SMTP 协议**等等。我们把应用层交互的数据单元称为报文。

 		域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 

 		**超文本传输协议**（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。 

### 总结

![](C:\Users\15893\Pictures\Saved Pictures\164e529309f0fa33.webp)

## 面试重点

### 1.TCP三次握手和四次挥手

![](C:\Users\15893\Pictures\Saved Pictures\5d4e8c89-fc42-3862-bdb8-399bc982f410.png)

**为什么有三次握手？**

三次握手目的是建立可靠的通信信道，双方都确认自己与对方的发送与接收是正常的。

- 第一次握手：Client什么都不能确认；Service确认对方发送正常
- 第二次握手：Client确认自己发送、接收正常，对方发送、接收正常；Service确认自己接收正常，对方发送正常
- 第三次握手：Client确认自己发送、接收正常，对方发送、接收正常；Service确认自己接收正常，对方发送、接收正常

**综上所述，三次握手少一次都不行**

**但由于即使是三次握手也不能完全保证传输可靠，四次、五次更多次都不能100%保证，所以三次握手足矣**

**为什么要四次挥手？**

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

### 2.TCP与UDP的区别

![](C:\Users\15893\Pictures\Saved Pictures\162db5e97e9a9e01.webp)

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： **QQ 语音、 QQ 视频 、直播等等**

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。**TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。**

### 3.TCP如何保证可靠传输

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **停止等待协议** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8.  **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

**流量控制**

- TCP 利用滑动窗口实现流量控制。
- 流量控制是为了控制发送方发送速率，保证接收方来得及接收。
- 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

**拥塞控制**

 TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。 

### 4.在浏览器输入url地址，显示主页的过程

![](C:\Users\15893\Pictures\Saved Pictures\162db5e985aabdbe.webp)

**状态码**

![](C:\Users\15893\Pictures\Saved Pictures\1633e19dba27ed00.webp)

### 5.http的请求报文内容

**由四部分组成：请求行，请求头，空行，请求体（请求数据）**

- 请求头：请求方法字段+空格+URL字段+空格+http协议版本字段
- 请求头：有一些键值对组成，常见的有：
  1. User-Agent：产生请求的浏览器类型
  2. Accept：客户端可是被的内容类型列表
  3. Host：请求的主机名

- 请求体：post、put等请求携带的数据

![](C:\Users\15893\Pictures\Saved Pictures\16b545c9bab6133b.webp)

### 6.http的响应报文内容

**响应报文由四部分组成：响应行，响应头，空行，响应体**

- 响应行：由协议版本+空格+状态码+空格+状态码原因短语组成
- 响应头：响应部首组成（与请求头的键值对相似）
- 响应体：服务器响应的数据

### 7.http的部首

- 通用首部（请求和响应都可以使用）：
  - Cache-Control：控制缓存
  - Connection：连接管理、逐条部首
  - Transfor-Encoding：报文主体的传输编码格式
  - Date：创建报文的日期

- 请求首部字段：
  - Accept：客户端或代理能够处理的媒体类型
  - Accept-Encoding：优先可处理的编码格式
  - If-Match：比较实体标记
  - Range：实体的字节范围请求
  - Authorization：web的认证信息
  - Host：请求资源所在服务器
  - User-Agent：客户端程序信息

- 响应首部字段：
  - Location：零客户端重定向的URL
  - ETag：能够表示资源唯一资源的字符串
  - Server：服务器的信息

- 实体首部字段：
  - Allow：资源可支持http请求的方法
  - Last-Modified：资源最后的修改资源

### 8 HTTP长连接、短连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**

### 9.http的发展史

**HTTP0.9**

- 只有GET请求方式
- 没有HEADER等描述数据的信息
- 服务端响应后立即关闭TCP连接

**HTTP1.0**

- 请求方式新增了POST，DELETE，PUT，HEADER等方式
- 新增了status code和header相关内容
- 增加了多字符集支持，多部分发送，权限，缓存等

**HTTP1.1**

- 长连接：HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，其中长连接也就是对应在HTTP1.1中的`Connection： keep-alive`，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
- 增加了hos头处理： 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。 而 HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 

- 缓存处理：Http1.0使用header中的If-Modified-Since，Expires来作为缓存判断条件， HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 
- 带宽优化及网络连接的使用：HTTP1.0如果客户端只需要某对象的一部分，而服务器将整个对象送过来，HTTP1.1在请求头中引入了range，允许只请求资源的某个部分，返回码206
- 错误通知管理：新增24个错误状态响应码

**HTTP1.0和HTTP1.1的问题**

- 两者都可以成为HTTP1.x，在传输数据时，每次都需要重新建立连接，增加了大量的延迟
- 在传输数据时所有内容都是明文，无法保证安全
- header里携带的内容过大，而且每次请求基本不怎么变化，增加了传输成本
- keep-alive会给服务端带来大量的性能压力，同时也无法解决线头阻塞问题

**Https**

最 初，HTTPS是与SSL一起使用的，在SSL逐渐演变到TLS时（其实两个是一个东西，只是名字不同而已） 。

- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的TLS加密传输协议。
- HTTP和HTTPS使用的是完全不同的连接方式，用的默认端口也不一样，前者是80，后者是443。
- HTTPS的连接很简单，HTTPS协议是由TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。

**谷歌提出SPDY**

SPDY综合了HTTP和HTTPS：

1. 降低延迟：采用多路复用，通过多个请求stream共享一个TCP连接。
2. 请求优先级：由于多路复用可能导致关键请求被阻塞，SPDY允许给每个request设置优先级，比如浏览器加载的首页优先级高，而css、js次之。
3. header压缩：选择合适的算法压缩header
4. 保留https和TSL的加密传输协议
5. 服务端推送，例如请求index.html文件时,不用等待其内部链接的文件请求发送，服务端会将index.js和index.css推送（Push）到客户端。

 ![img](https://user-gold-cdn.xitu.io/2019/11/7/16e437709704ab39?imageslim)  

SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 

**Http2.0**

Http2.0的特性大部分与SPDY类似：

- **新的二进制格式：** HTTP1.x的解析是基于文本。  HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 

- **多路复用：**即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

  **多路复用与keep-alive的区别：**

 ![多路复用与keep-alive的区别](https://user-gold-cdn.xitu.io/2019/11/7/16e43770eaa5bcc1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

- header压缩
- 服务端推送

**Http3.0**

HTTP3.0，也称作HTTP over QUIC。HTTP3.0的核心是QUIC(读音quick)协议，由Google在2015年提出的SPDY v3演化而来的新协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层UDP上的协议，可以定义成：HTTP3.0基于UDP的安全可靠的HTTP2.0协议。

 ![图片描述](https://user-gold-cdn.xitu.io/2019/11/7/16e43770f7476789?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

- 使用UDP协议，减少了TCP三次握手即TLS握手时间
- 多路复用丢包时的线头阻塞问题： QUIC中一个连接上的多个stream之间没有依赖。 
- 优化重传策略： TCP丢包是，如果接收方没有在时间内返回对应需要的ack，服务器会采用相同的syn重发，而此时服务器接收到ack时，不能确定是初传还是重传的确认信息。QUIC为了避免这个问题，发送端在传送封包时，初始与重传的每一个封包都改用一个新的编号，unique packet number，每一个编号都唯一而且严格递增，这样每次在收到ACK时，就可以依据编号明确的判断这个ACK是来自初始封包或者是重传封包。 

- 流量控制：QUIC采用了连线层 (connection flow control) 和 Stream 层的 (stream flow control) 流量控制，限制单一 Stream 可以占用的最大buffer size。

- 连接迁移：TCP连接基于四元组（源端口和IP，目的端口和IP），切换连接时会发生变化，之前建立的TCP连接需要等待其自动断开，然后再重新建立连接。**QUIC 的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持。QUIC 连接不以四元组作为标识，而是使用一个 64 位的随机数，这个随机数被称为 Connection ID，对应每个stream，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持。**

